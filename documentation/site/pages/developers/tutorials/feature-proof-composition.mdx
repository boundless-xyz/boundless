---
title: Proof Composition
description: Proof composition allows you to build upon existing proofs by verifying them within new zkVM guest programs.
---

import { StripRustCodeComments } from "../../../components/strip-rust-code-comments";

# Proof Composition

> Prerequisite Reading: [Request a Proof](/developers/tutorials/request), [Proof Lifecycle](/developers/proof-lifecycle)

## Overview

Proof composition enables you to build upon existing proofs by verifying them within new zkVM guest programs. This is particularly useful when you want to prove a sequence of related statements without reproving each step.

For example, let's say you have:
1. A proof that block `n` is valid
2. You want to prove that both blocks `n` and `n+1` are valid

Instead of reproving block `n`, you can:
1. Use the existing proof of block `n`
2. Prove only block `n+1` under the assumption that `n` is valid
3. Resolve this assumption by verifying the previous proof within your new proof

This approach is more efficient than reproving everything from scratch.

## How it Works

Proof composition works by:

1. Requesting a raw Groth16 proof from the Boundless Market
2. Using this proof as input to a new zkVM guest program
3. Verifying the proof within the guest program
4. Building upon the verified result to prove new statements

## Example: Composing Echo and Identity Proofs

The [Proof Composition example](https://github.com/boundless-xyz/boundless/tree/main/examples/composition) demonstrates how to compose proofs using the Echo and Identity guest programs.

First, we request a raw Groth16 proof from the Echo guest program:

<StripRustCodeComments>
```rust
# use boundless_market::contracts::{Input, Callback, Offer, Predicate, ProofRequest, Requirements};
# use guest_util::{ECHO_ELF, ECHO_ID};
# use crate::counter::{ICounter, ICounter::ICounterInstance};
# async fn main(image_id: Digest, journal: Journal) -> Result<()> {
let mut requirements = Requirements::new(image_id, Predicate::digest_match(journal.digest()));
if groth16 {
    requirements = requirements.with_groth16_proof();
}
# Ok(())
# }
```
</StripRustCodeComments>

We then use this proof as input to the Identity guest program:

<StripRustCodeComments>
```rust
# use boundless_market::contracts::{Input, Callback, Offer, Predicate, ProofRequest, Requirements};
# use risc0_zkvm::sha::{Digest, Digestible};
# use guest_util::{ECHO_ELF, ECHO_ID, IDENTITY_ELF, IDENTITY_ID};
# use boundless_market::storage::StorageProvider;
# async fn boundless_proof(
#     client: &Client<P, S>,
#     elf: impl AsRef<[u8]>,
#     guest_env: GuestEnv,
#     groth16: bool,
# ) -> Result<()> {
#     let (journal, seal) = client.prove(elf, guest_env, groth16).await?;
#     Ok((journal, seal))
# }
# async fn run<P: StorageProvider>(
#     private_key: PrivateKeySigner,
#     rpc_url: Url,
#     order_stream_url: Option<Url>,
#     storage_provider: P,
#     boundless_market_address: Address,
#     set_verifier_address: Address,
#     counter_address: Address,
# ) -> Result<()> {
// Build the IDENTITY input from the ECHO receipt
let identity_input = (Digest::from(ECHO_ID), echo_receipt);
let identity_guest_env =
    Input::builder().write_frame(&postcard::to_allocvec(&identity_input)?).build_env()?;

// Request a proof from the Boundless market using the IDENTITY guest
let (identity_journal, identity_seal) =
    boundless_proof(&boundless_client, IDENTITY_ELF, identity_guest_env, false)
        .await
        .context("failed to prove IDENTITY")?;
# Ok(())
# }
```
</StripRustCodeComments>

Finally, we can use the composed proof to interact with a smart contract:

<StripRustCodeComments>
```rust
# use boundless_market::contracts::{Input, Callback, Offer, Predicate, ProofRequest, Requirements};
# use risc0_zkvm::sha::{Digest, Digestible};
# use alloy::{
#    network::Ethereum,
#    primitives::{utils::parse_ether, Address, Bytes, B256},
#    providers::Provider,
#    signers::local::PrivateKeySigner,
#    sol_types::SolCall,
# };
# use guest_util::{ECHO_ELF, ECHO_ID, IDENTITY_ELF, IDENTITY_ID};
# use crate::counter::{ICounter, ICounter::ICounterInstance};
# async fn interact(request: ProofRequest) -> Result<(), Box<dyn std::error::Error>> {
// Interact with the Counter contract using the composed proof
let counter = ICounterInstance::new(counter_address, boundless_client.provider());
let journal_digest = B256::from_slice(identity_journal.digest().as_bytes());
let image_id = B256::from_slice(Digest::from(IDENTITY_ID).as_bytes());
let call_increment =
    counter.increment(identity_seal, image_id, journal_digest).from(boundless_client.caller());

// Execute the transaction
let pending_tx = call_increment.send().await?;
let tx_hash = pending_tx
    .with_timeout(Some(TX_TIMEOUT))
    .watch()
    .await?;
# Ok(())
# }
```
</StripRustCodeComments>

> Relevant links: [Proof Composition Example](https://github.com/boundless-xyz/boundless/tree/main/examples/composition)
