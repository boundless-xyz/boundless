---
title: Request a Proof
description: How to request a proof from the Boundless market.
---

import PricingCalculator from "../../components/pricing-calculator";

# Request a Proof

The interface for developers to use the Boundless core services is the Boundless Market, developers interact with this by sending a proof request. This will allow provers to lock in the request, and fulfill the request by providing the proof  This can be done programmatically using the boundless-market crate or with the Boundless CLI.

## Programmatically

The recommended flow of requesting a proof is:

1. [Create a boundless client.](#1-create-a-boundless-client)
2. [Upload the program executable (ELF binary) to IPFS.](#2-upload-program-executable-to-ipfs)
3. [Upload the input of your program to IPFS.](#3-upload-the-input-of-your-program-to-ipfs)
4. [Execute the program to estimate the total number of cycles, and to get the journal.](#4-execute-the-program-to-estimate-cycles-and-to-get-the-journal)
5. [Create a proving request with URLs to the executable and inputs, the journal hash, the imageID, and the offer details (such as price range and timeout length).](#5-create-a-proof-request)
6. [Submit the request to the market.](#6-submit-a-request)
7. Wait for the request to be fulfilled, returning the journal and the seal.

The Boundless Foundry Template provides a full code example of this workflow in [`apps/src/main.rs`](https://github.com/boundless-xyz/boundless-foundry-template/blob/main/apps/src/main.rs#L58).

### 1. Create a Boundless Client

To facilitate communication with the Boundless market, developers can use the `Client` struct from the boundless-market crate. `Client` manages interaction with the proof market contract and handles the necessary authentication and transaction signing.

To instantiate a boundless client, you will need a wallet with sufficient funds on Sepolia (you will have to provide the maximum amount you are willing to pay for a proof request upfront), a working Sepolia RPC provider, and the proof market and set verifier contract addresses:

```rust
let boundless_client = ClientBuilder::default()
    .with_rpc_url(rpc_url)
    .with_boundless_market_address(boundless_market_address)
    .with_set_verifier_address(set_verifier_address)
    .with_order_stream_url(order_stream_url)
    .with_storage_provider_config(storage_config.clone())
    .with_private_key(private_key)
    .build()
    .await?;
```

For the latest deployment address, please see [Deployments](/deployments).

> Relevant links: [Sepolia Faucet](https://www.sepoliafaucet.io), [Sepolia Public RPCs](https://chainlist.org/chain/11155111), [Boundless Deployments Reference](/deployments)

### 2. Upload Program Executable to IPFS

The ELF binary, also known as the image, of the program should be accessible to provers. This is done by uploading the ELF to a compatible storage provider. The supported options are listed in `boundless_market::BuiltInStorageProvider` (see [`BuiltInStorageProvider`](https://github.com/boundless-xyz/boundless/blob/8b6c70d1596c113f7eb0eb137b8932e62065cf0a/crates/boundless-market/src/storage.rs#L46)).

The recommended storage provider is IPFS, specifically through [Pinata](https://pinata.cloud) (the free tier should be sufficient for most Boundless use cases). To use Pinata, fetch the required JWT credential and set it to the `PINATA_JWT` environment variable in the `.env` file.

With the `PINATA_JWT` set, the executable can be uploaded to IPFS with the `upload_image` method:

```rust
let image_url = boundless_client.upload_image(ELF).await?;
```

### 3. Upload the Input of Your Program to IPFS

To execute and run proving, the prover requires the inputs of the program. Similar to the program executable, the program inputs are uploaded to a compatible storage provider. The supported options are listed in `boundless_market::BuiltInStorageProvider` (see [`BuiltInStorageProvider`](https://github.com/boundless-xyz/boundless/blob/8b6c70d1596c113f7eb0eb137b8932e62065cf0a/crates/boundless-market/src/storage.rs#L46)).

The recommended storage provider is IPFS (see [Upload Program Executable to IPFS](#upload-program-executable-to-ipfs)).

With the `PINATA_JWT` set, the inputs can be uploaded to IPFS with the `upload_input` method:

```rust
let image_url = boundless_client.upload_image(ELF).await?;
```

> Relevant links: [BuiltInStorageProvider](https://github.com/boundless-xyz/boundless/blob/8b6c70d1596c113f7eb0eb137b8932e62065cf0a/crates/boundless-market/src/storage.rs#L46), [Pinata](https://pinata.cloud), [Get JWT Credentials from Pinata](https://docs.pinata.cloud/account-management/api-keys), [upload\_image for PinataStorageProvider](https://github.com/boundless-xyz/boundless/blob/8b6c70d1596c113f7eb0eb137b8932e62065cf0a/crates/boundless-market/src/storage.rs#L213)

### 4. Execute the Program to Estimate Cycles and to Get the Journal

Before sending a proof request, developers should execute the program. This achieves a few separate goals:

- It estimates the number of cycles in the program, which can be used to estimate the cost of the proof request offer.
- It makes sure that the program executes without errors, saving the developer money by not sending unprovable proof requests to the market.
- It retrieves the journal, the public outputs of the program, which are used to check proof validity along with the imageID.

To execute the program and retrieve the cycle count (in MCycles), and journal:

```rust
let env = ExecutorEnv::builder().write_slice(&input).build()?;
let session_info = default_executor().execute(env, ELF)?;
let mcycles_count = session_info
.segments
       .iter()
       .map(|segment| 1 << segment.po2)
       .sum::<u64>()
       .div_ceil(1_000_000);
let journal = session_info.journal;
```

> Relevant links: [ExecutorEnvBuilder](https://docs.rs/risc0-zkvm/latest/risc0_zkvm/struct.ExecutorEnvBuilder.html)

### 5. Create a Proof Request

A proof request consists of four essential components that specify which program needs to be proven and under what conditions:

```rust showLineNumbers
let request = ProofRequest::default()
  .with_image_url(&image_url)
  .with_input(Input::url(&input_url))
  .with_requirements(Requirements::new(ECHO_ID, Predicate::digest_match(journal.digest())))
  .with_offer(
    Offer::default()
      // The market uses a reverse Dutch auction mechanism to match requests with provers.
      // Each request has a price range that a prover can bid on. One way to set the price
      // is to choose a desired (min and max) price per million cycles and multiply it
      // by the number of cycles. Alternatively, you can use the `with_min_price` and
      // `with_max_price` methods to set the price directly.
      .with_min_price_per_mcycle(parse_ether("0.001")?, mcycles_count)
      // NOTE: If your offer is not being accepted, try increasing the max price.
      .with_max_price_per_mcycle(parse_ether("0.002")?, mcycles_count)
      // The timeout is the maximum number of blocks the request can stay
      // unfulfilled in the market before it expires. If a prover locks in
      // the request and does not fulfill it before the timeout, the prover can be
      // slashed.
      .with_timeout(1000),
  );
```

1. Program Image (`with_image_url`) (line #2)
2. Program Input (`with_input`) (line #3)
3. Requirements (`with_requirements`) (line #4)
4. Offer (`with_offer`) (line #5)

The program image and program inputs are discussed in steps 2 and 3 respectively.

#### Proof Requirements

The requirements ensure proof integrity and correctness by checking the [image ID](https://dev.risczero.com/terminology#image-id) (a unique identifier of each ELF binary run in the zkVM) and the hash of the journal. By checking both the imageID and the journal hash, we can be sure that the provers are working with the correct program and that the outputs match the expected outputs (the ones generated by the execution in step 4).

#### Offer Details

The offer details are specified with `with_offer()`. This allows the requestor to set the price range per million cycles (MCycles), and long the request remains valid (known as the timeout). The price mechanism helps match the request with provers.

> Relevant links: [Cycles](https://dev.risczero.com/terminology#clock-cycles), [ELF Binary](https://dev.risczero.com/terminology#elf-binary)

### 6. Submit a Request

Once the request is configured, it can submitted to the market:

```rust
let request_id = boundless_client.submit_request(&request).await?;
```

This will send the request onchain in a transaction. Using `boundless_client.submit_request_offchain`, you can send your request off-chain through the order-stream service. This will not cost any gas, but does require you to deposit funds to the market first.

The `submit_request` method returns a `request_id` which can be used to track the proof request (see [Boundless Indexer](https://indexer.beboundless.xyz)).

### 7. Wait for the Request to Be Fulfilled

Once fulfilled, the journal and seal are returned. The journal contains the public outputs of the guest program, and the seal.

```rust
let (_journal, seal) = boundless_client
  .wait_for_request_fulfillment(
    request_id,
    Duration::from_secs(5), // check every 5 seconds
    request.expires_at(),
  )
  .await?;
```

> Relevant links: [Seal](https://dev.risczero.com/terminology#seal), [Journal](https://dev.risczero.com/terminology#journal)

## Requesting a Proof via the Market CLI

In some circumstances, submitting a proof request via the command line can be advantageous, such as the early testing.

### Market Client CLI

The market client CLI builds upon the [`boundless_market::contracts`](https://github.com/boundless-xyz/boundless/tree/main/crates/boundless-market/src/contracts) library. It covers multiple market interactions such as submitting proof requests, cancelling requests, executing dry runs, requesting the status of a given request, retrieving the journal and seal of a fulfilled request and verifying a proof.

To submit a proof, a valid `request.yaml` is required, this config file will specify the parameters of the request:

- Request ID
  - This can be specified, or if set to 0, a random ID will be assigned.
- Requirements:
  - The ImageID of the program being proven
  - The contents of the outputs of the program, the journal. This is to make sure the outputs are as expected.
- Image URL
  - The link to the ELF binary stored on a [compatible storage provider](https://github.com/boundless-xyz/boundless/blob/8b6c70d1596c113f7eb0eb137b8932e62065cf0a/crates/boundless-market/src/storage.rs#L46), preferably IPFS.
- Input:
  - The input bytes are hex encoded and passed to the program for execution.
- Offer Details:
  - This includes the minimum and maximum price for the proof request, the block number to open bidding, the price ramp up period, how many blocks before the request should timeout, and the lock in stake the prover has to escrow to submit a bid.

```yaml [request.yaml]
# Unique ID for this request, constructed from the client address and a 32-bit index.
# Constructed as (address(client) << 32) | index
id: 0 # if set to 0, gets overwritten by a random id

# Specifies the requirements for the delivered proof, including the program that must be run,
# and the constraints on the journal's value, which define the statement to be proven.
requirements:
  imageId: "722705a82a1dab8369b17e16bac42c9c538057fc1d32933d21ea2b47f292efb4"
  predicate:
    predicateType: PrefixMatch
    data: "57656420"

# A public URI where the program (i.e. image) can be downloaded. This URI will be accessed by
# provers that are evaluating whether to bid on the request.
imageUrl: "https://dweb.link/ipfs/QmTx3vDKicYG5RxzMxrZEiCQJqhpgYNrSFABdVz9ri2m5P"

# Input to be provided to the zkVM guest execution.
input:
  inputType: Inline
  data: "576564204a756c2020332031343a33373a31322050445420323032340a"

# Offer specifying how much the client is willing to pay to have this request fulfilled
offer:
  minPrice: 100000000000000
  maxPrice: 2000000000000000
  biddingStart: 0 # if set to 0, gets overwritten by the current block height
  rampUpPeriod: 100
  timeout: 300 # 1 hour at 12s block times.
  lockinStake: 100000000000000
```

To submit a request, run the following from the boundless monorepo main directory:

```sh [Terminal]
RUST_LOG=info,boundless_market=debug cargo run --bin cli -- submit-request request.yaml
```

To wait until the submitted request has been fulfilled, the `--wait` option can be added:

```sh [Terminal]
# [!code word:--wait]
RUST_LOG=info,boundless_market=debug cargo run --bin cli -- submit-request request.yaml --wait
```

## Pricing A Request

The `request.yaml` specifies the details of the offer. This section will cover these offer details and the interactions between the requestor and the prover in the early stages of the proof request, i.e. price auction, bid submission and prover lock in.

An offer contains the following:

- Pricing parameters
- Minimum price
- Maximum price
- Bidding start (defined as a block number)
- Length of ramp-up period (measured in blocks since the start of the bid)
- Timeout (measured in blocks since the start of the bid)
- Lock-in stake

For example, an offer might specify:

- Pricing parameters
  - Minimum price: 1 Ether
  - Maximum price: 2 Ether
- Bidding start: Block number 1000
- Length of ramp-up period: 5 blocks
- Timeout: 100 blocks
- Lock-in stake: 4 Ether

The pricing parameters are used to determine the reward that gets paid-out when the request is fulfilled (ie, the proof has been verified). The reward is governed by the price function. Its inputs are:

- The offer.
- The number of blocks that have passed since the bidding started.

The function works like so:

- During the discovery period (the initial phase of the auction before bidding start), the price is just the minimum price.
- During the ramp-up period (which immediately follows the discovery period), the price grows linearly up-to the maximum price.
- After the ramp-up period, the price is just the maximum price.

Continuing with the example offer given above, the price is constant (1 Ether, its minimum) for the first 10 blocks; on block 11 it jumps to 1.2 Ether; on 12 it jumps to 1.4 Ether; on 15 it reaches 2 Ether (its maximum), and remains at that value until the offer expires.

When a prover locks-in a request, they are agreeing to be paid the reward offered by this function at the time of their bid.

## Pricing Calculator

Use this interactive calculator to get suggested request parameters based on your program's complexity and desired proof time:

<PricingCalculator />
