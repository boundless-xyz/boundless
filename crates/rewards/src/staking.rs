// Copyright 2026 Boundless Foundation, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Staking position tracking and rewards computation.

use alloy::primitives::{Address, U256};
use std::collections::{HashMap, HashSet};

/// Types of staking events from the blockchain
#[derive(Debug, Clone)]
pub enum StakeEvent {
    Created { owner: Address, amount: U256 },
    Added { owner: Address, new_total: U256 },
    UnstakeInitiated { owner: Address },
    UnstakeCompleted { owner: Address },
    RewardDelegateChanged { delegator: Address, new_delegate: Address },
    VoteDelegateChanged { delegator: Address, new_delegate: Address },
}

/// Staking event with block timestamp and epoch information
#[derive(Debug, Clone)]
pub struct TimestampedStakeEvent {
    pub block_number: u64,
    pub block_timestamp: u64,
    pub transaction_index: u64,
    pub log_index: u64,
    pub epoch: u64,
    pub event: StakeEvent,
}

/// Represents a staking position with delegation information
#[derive(Debug, Clone)]
pub struct StakingPosition {
    /// Amount of tokens staked
    pub staked_amount: U256,
    /// Whether the stake is being withdrawn
    pub is_withdrawing: bool,
    /// Address to whom rewards are delegated
    pub rewards_delegated_to: Option<Address>,
    /// Address to whom voting power is delegated
    pub votes_delegated_to: Option<Address>,
    /// Rewards generated by this position (regardless of delegation)
    pub rewards_generated: U256,
}

/// Information about rewards actually received by an address in an epoch
/// This represents the actual recipient of rewards (could be via delegation)
#[derive(Debug, Clone)]
pub struct StakerRewardInfo {
    /// Address that received the rewards
    pub staker_address: Address,
    /// Staking power (veZKC balance) that generated these rewards
    pub staking_power: U256,
    /// Rewards actually received by this address
    pub rewards_earned: U256,
    /// Percentage of total rewards received
    pub percentage: f64,
}

/// Complete staking data for a single epoch (positions + rewards)
#[derive(Debug, Clone)]
pub struct EpochStakingData {
    /// The epoch number
    pub epoch: u64,
    /// Staking positions by staker address (tracks who owns positions and rewards generated)
    pub positions_by_staker: HashMap<Address, StakingPosition>,
    /// Total staked amount in this epoch
    pub total_staked: U256,
    /// Number of active stakers
    pub num_stakers: usize,
    /// Number of stakers in withdrawal
    pub num_withdrawing: usize,
    /// Total staking emissions for this epoch
    pub total_staking_emissions: U256,
    /// Total staking power in this epoch
    pub total_staking_power: U256,
    /// Rewards by recipient address (tracks who actually received rewards)
    pub rewards_by_address: HashMap<Address, StakerRewardInfo>,
    /// Number of participants who earned rewards
    pub num_reward_recipients: usize,
}

/// Aggregate data for a single staker across all epochs
#[derive(Debug, Clone)]
pub struct StakerAggregate {
    /// Staker address
    pub staker_address: Address,
    /// Current staked amount (latest epoch)
    pub current_staked: U256,
    /// Whether currently withdrawing
    pub is_withdrawing: bool,
    /// Current rewards delegate
    pub rewards_delegated_to: Option<Address>,
    /// Current votes delegate
    pub votes_delegated_to: Option<Address>,
    /// Total rewards generated by positions owned by this address
    pub total_rewards_generated: U256,
    /// Total rewards actually received by this address (from own positions or delegations)
    pub total_rewards_earned: U256,
    /// Number of epochs participated in
    pub epochs_participated: u64,
}

/// Summary statistics across all epochs
#[derive(Debug, Clone)]
pub struct StakingSummary {
    /// Total staked amount in the latest epoch
    pub current_total_staked: U256,
    /// Total unique stakers ever
    pub total_unique_stakers: usize,
    /// Current number of active stakers
    pub current_active_stakers: usize,
    /// Current number of stakers withdrawing
    pub current_withdrawing: usize,
    /// Total staking emissions across all epochs
    pub total_staking_emissions_all_time: U256,
    /// Total unique reward recipients across all epochs
    pub total_unique_reward_recipients: usize,
}

/// Complete result of staking data computation
#[derive(Debug, Clone)]
pub struct StakingDataResult {
    /// Staking data by epoch
    pub epochs: Vec<EpochStakingData>,
    /// Aggregate data by staker
    pub staker_aggregates: HashMap<Address, StakerAggregate>,
    /// Summary statistics
    pub summary: StakingSummary,
}

/// Compute all staking data (positions and rewards) for all epochs
pub fn compute_staking_data(
    current_epoch: u64,
    processing_end_epoch: u64,
    timestamped_stake_events: &[TimestampedStakeEvent],
    staking_emissions_by_epoch: &HashMap<u64, U256>,
    staking_power_by_address_by_epoch: &HashMap<(Address, u64), U256>,
    total_staking_power_by_epoch: &HashMap<u64, U256>,
) -> anyhow::Result<StakingDataResult> {
    // First compute positions for all epochs
    let positions_by_epoch =
        compute_positions(timestamped_stake_events, current_epoch, processing_end_epoch)?;

    // Now compute rewards and combine with positions
    let mut epochs = Vec::new();
    let mut staker_aggregates: HashMap<Address, StakerAggregate> = HashMap::new();

    // Track statistics
    let mut all_stakers_ever = HashSet::new();
    let mut all_reward_recipients_ever = HashSet::new();
    let mut total_staking_emissions_all_time = U256::ZERO;

    for mut epoch_positions in positions_by_epoch {
        let epoch = epoch_positions.epoch;

        // Get emissions for this epoch
        let staking_emissions =
            staking_emissions_by_epoch.get(&epoch).copied().unwrap_or(U256::ZERO);

        // Get total staking power
        let total_staking_power =
            total_staking_power_by_epoch.get(&epoch).copied().unwrap_or(U256::ZERO);

        // Compute rewards for this epoch
        let mut rewards_by_recipient = HashMap::new();

        if staking_emissions > U256::ZERO {
            // First: Calculate rewards GENERATED by each position based on staked amount
            // This shows the value created by each position regardless of delegation
            if epoch_positions.total_staked > U256::ZERO {
                for position in epoch_positions.positions.values_mut() {
                    if position.staked_amount > U256::ZERO {
                        // Rewards generated based on position's stake proportion
                        position.rewards_generated = (position.staked_amount * staking_emissions)
                            / epoch_positions.total_staked;
                    }
                }
            }

            // Second: Determine who RECEIVES the rewards using staking power
            // Staking power accounts for delegations (delegator has 0, delegate has sum)
            if total_staking_power > U256::ZERO {
                for ((staker_address, staker_epoch), staking_power) in
                    staking_power_by_address_by_epoch
                {
                    if *staker_epoch == epoch && *staking_power > U256::ZERO {
                        // Calculate rewards to receive based on staking power
                        let rewards_to_receive =
                            (*staking_power * staking_emissions) / total_staking_power;

                        // Find who actually receives these rewards
                        // Note: The staker with staking_power might be receiving delegated rewards
                        let recipient_info = rewards_by_recipient
                            .entry(*staker_address)
                            .or_insert_with(|| StakerRewardInfo {
                                staker_address: *staker_address,
                                staking_power: U256::ZERO,
                                rewards_earned: U256::ZERO,
                                percentage: 0.0,
                            });
                        recipient_info.staking_power += staking_power;
                        recipient_info.rewards_earned += rewards_to_receive;

                        all_reward_recipients_ever.insert(*staker_address);
                    }
                }

                // Calculate percentages for recipients
                for recipient_info in rewards_by_recipient.values_mut() {
                    recipient_info.percentage = (recipient_info.staking_power * U256::from(10000)
                        / total_staking_power)
                        .to::<u64>() as f64
                        / 100.0;
                }
            }
        }

        // Track all stakers from positions
        for address in epoch_positions.positions.keys() {
            all_stakers_ever.insert(*address);
        }

        // Update aggregates
        for (address, position) in &epoch_positions.positions {
            let aggregate = staker_aggregates.entry(*address).or_insert_with(|| StakerAggregate {
                staker_address: *address,
                current_staked: U256::ZERO,
                is_withdrawing: false,
                rewards_delegated_to: None,
                votes_delegated_to: None,
                total_rewards_generated: U256::ZERO,
                total_rewards_earned: U256::ZERO,
                epochs_participated: 0,
            });

            // Update with latest position data (since we process epochs in order)
            aggregate.current_staked = position.staked_amount;
            aggregate.is_withdrawing = position.is_withdrawing;
            aggregate.rewards_delegated_to = position.rewards_delegated_to;
            aggregate.votes_delegated_to = position.votes_delegated_to;
            aggregate.total_rewards_generated += position.rewards_generated;
            aggregate.epochs_participated += 1;
        }

        // Update aggregates from reward recipients (tracks who actually received rewards)
        for (recipient_address, reward_info) in &rewards_by_recipient {
            // Ensure recipient has an aggregate entry (they may only be receiving delegated rewards)
            let aggregate =
                staker_aggregates.entry(*recipient_address).or_insert_with(|| StakerAggregate {
                    staker_address: *recipient_address,
                    current_staked: U256::ZERO,
                    is_withdrawing: false,
                    rewards_delegated_to: None,
                    votes_delegated_to: None,
                    total_rewards_generated: U256::ZERO,
                    total_rewards_earned: U256::ZERO,
                    epochs_participated: 0,
                });

            // Add earned rewards (these are rewards actually received)
            aggregate.total_rewards_earned += reward_info.rewards_earned;
        }

        total_staking_emissions_all_time += staking_emissions;

        // Create combined epoch data
        let num_reward_recipients = rewards_by_recipient.len();
        epochs.push(EpochStakingData {
            epoch,
            positions_by_staker: epoch_positions.positions,
            total_staked: epoch_positions.total_staked,
            num_stakers: epoch_positions.num_stakers,
            num_withdrawing: epoch_positions.num_withdrawing,
            total_staking_emissions: staking_emissions,
            total_staking_power,
            rewards_by_address: rewards_by_recipient,
            num_reward_recipients,
        });
    }

    // Get latest epoch data for current stats
    let latest_epoch = epochs.last().ok_or_else(|| anyhow::anyhow!("No epoch data computed"))?;

    // If a user existed in earlier epochs but doesn't have a position in the latest epoch,
    // it means they have fully withdrawn. We don't remove them entirely as we still
    // keep track of and display their other data like total_rewards_earned, etc.
    // But we do reset their current state fields to reflect that they have fully withdrawn.
    let latest_positions = &latest_epoch.positions_by_staker;
    for aggregate in staker_aggregates.values_mut() {
        if !latest_positions.contains_key(&aggregate.staker_address) {
            aggregate.current_staked = U256::ZERO;
            aggregate.is_withdrawing = false;
            aggregate.rewards_delegated_to = None;
            aggregate.votes_delegated_to = None;
        }
    }

    let summary = StakingSummary {
        current_total_staked: latest_epoch.total_staked,
        total_unique_stakers: all_stakers_ever.len(),
        current_active_stakers: latest_epoch.num_stakers,
        current_withdrawing: latest_epoch.num_withdrawing,
        total_staking_emissions_all_time,
        total_unique_reward_recipients: all_reward_recipients_ever.len(),
    };

    Ok(StakingDataResult { epochs, staker_aggregates, summary })
}

/// Structure for position computation
#[derive(Debug, Clone)]
pub struct EpochStakingPositions {
    pub epoch: u64,
    pub positions: HashMap<Address, StakingPosition>,
    pub total_staked: U256,
    pub num_stakers: usize,
    pub num_withdrawing: usize,
}

/// Compute staking positions from timestamped events
fn compute_positions(
    timestamped_events: &[TimestampedStakeEvent],
    _current_epoch: u64,
    processing_end_epoch: u64,
) -> anyhow::Result<Vec<EpochStakingPositions>> {
    // Tracking current state
    let mut current_stakes: HashMap<Address, U256> = HashMap::new();
    let mut current_withdrawing: HashMap<Address, bool> = HashMap::new();
    let mut current_vote_delegations: HashMap<Address, Address> = HashMap::new();
    let mut current_reward_delegations: HashMap<Address, Address> = HashMap::new();

    // Results by epoch
    let mut epoch_positions = Vec::new();
    let mut last_processed_epoch = None;

    // Process events in chronological order
    for event in timestamped_events {
        // Check if we've moved to a new epoch
        if last_processed_epoch.is_some() && Some(event.epoch) != last_processed_epoch {
            // Save snapshot for the previous epoch before moving on
            if let Some(prev_epoch) = last_processed_epoch {
                epoch_positions.push(create_epoch_snapshot(
                    prev_epoch,
                    &current_stakes,
                    &current_withdrawing,
                    &current_vote_delegations,
                    &current_reward_delegations,
                ));
            }
        }

        // Apply the event to update current state
        match &event.event {
            StakeEvent::Created { owner, amount } => {
                current_stakes.insert(*owner, *amount);
                current_withdrawing.insert(*owner, false);
            }
            StakeEvent::Added { owner, new_total } => {
                current_stakes.insert(*owner, *new_total);
            }
            StakeEvent::UnstakeInitiated { owner } => {
                current_withdrawing.insert(*owner, true);
            }
            StakeEvent::UnstakeCompleted { owner } => {
                current_stakes.remove(owner);
                current_withdrawing.remove(owner);
                current_vote_delegations.remove(owner);
                current_reward_delegations.remove(owner);
            }
            StakeEvent::RewardDelegateChanged { delegator, new_delegate } => {
                if *new_delegate == Address::ZERO {
                    current_reward_delegations.remove(delegator);
                } else {
                    current_reward_delegations.insert(*delegator, *new_delegate);
                }
            }
            StakeEvent::VoteDelegateChanged { delegator, new_delegate } => {
                if *new_delegate == Address::ZERO {
                    current_vote_delegations.remove(delegator);
                } else {
                    current_vote_delegations.insert(*delegator, *new_delegate);
                }
            }
        }

        last_processed_epoch = Some(event.epoch);
    }

    // Process any remaining epochs up to processing_end_epoch
    for epoch in last_processed_epoch.unwrap_or(0)..=processing_end_epoch {
        if epoch_positions.iter().any(|e| e.epoch == epoch) {
            continue; // Already processed
        }

        epoch_positions.push(create_epoch_snapshot(
            epoch,
            &current_stakes,
            &current_withdrawing,
            &current_vote_delegations,
            &current_reward_delegations,
        ));
    }

    // Sort by epoch to ensure chronological order
    epoch_positions.sort_by_key(|e| e.epoch);

    Ok(epoch_positions)
}

fn create_epoch_snapshot(
    epoch: u64,
    stakes: &HashMap<Address, U256>,
    withdrawing: &HashMap<Address, bool>,
    vote_delegations: &HashMap<Address, Address>,
    reward_delegations: &HashMap<Address, Address>,
) -> EpochStakingPositions {
    let mut positions = HashMap::new();
    let mut total_staked = U256::ZERO;
    let mut num_withdrawing = 0;

    for (address, amount) in stakes {
        let is_withdrawing = withdrawing.get(address).copied().unwrap_or(false);
        if is_withdrawing {
            num_withdrawing += 1;
        }

        positions.insert(
            *address,
            StakingPosition {
                staked_amount: *amount,
                is_withdrawing,
                rewards_delegated_to: reward_delegations.get(address).copied(),
                votes_delegated_to: vote_delegations.get(address).copied(),
                rewards_generated: U256::ZERO, // Will be calculated later when rewards are computed
            },
        );

        total_staked += amount;
    }

    let num_stakers = positions.len();
    EpochStakingPositions { epoch, positions, total_staked, num_stakers, num_withdrawing }
}

#[cfg(test)]
mod tests {
    use super::*;
    use alloy::primitives::address;
    use std::collections::HashMap;

    fn make_event(epoch: u64, event: StakeEvent) -> TimestampedStakeEvent {
        TimestampedStakeEvent {
            block_number: epoch * 100,
            block_timestamp: epoch * 1000,
            transaction_index: 0,
            log_index: 0,
            epoch,
            event,
        }
    }

    #[test]
    fn test_per_epoch_positions_correct_after_unstake_completed() {
        // This test confirms that per-epoch position data is correct:
        // - User appears in epochs where they have a position
        // - User does NOT appear in epochs after UnstakeCompleted
        let alice = address!("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
        let stake_amount = U256::from(100);

        let events = vec![
            make_event(1, StakeEvent::Created { owner: alice, amount: stake_amount }),
            make_event(3, StakeEvent::UnstakeInitiated { owner: alice }),
            make_event(4, StakeEvent::UnstakeCompleted { owner: alice }),
        ];

        let result = compute_staking_data(
            5, // current_epoch
            5, // processing_end_epoch
            &events,
            &HashMap::new(),
            &HashMap::new(),
            &HashMap::new(),
        )
        .unwrap();

        // Epoch 1: Alice should be present, not withdrawing
        let epoch1 = result.epochs.iter().find(|e| e.epoch == 1).unwrap();
        assert!(epoch1.positions_by_staker.contains_key(&alice));
        assert_eq!(epoch1.positions_by_staker[&alice].staked_amount, stake_amount);
        assert!(!epoch1.positions_by_staker[&alice].is_withdrawing);

        // Epoch 3: Alice should be present AND withdrawing
        let epoch3 = result.epochs.iter().find(|e| e.epoch == 3).unwrap();
        assert!(epoch3.positions_by_staker.contains_key(&alice));
        assert!(epoch3.positions_by_staker[&alice].is_withdrawing);

        // Epoch 4: Alice completed unstake - should NOT be in positions
        let epoch4 = result.epochs.iter().find(|e| e.epoch == 4).unwrap();
        assert!(
            !epoch4.positions_by_staker.contains_key(&alice),
            "Alice should not appear in epoch 4 after UnstakeCompleted"
        );

        // Epoch 5: Alice should still NOT be in positions
        let epoch5 = result.epochs.iter().find(|e| e.epoch == 5).unwrap();
        assert!(
            !epoch5.positions_by_staker.contains_key(&alice),
            "Alice should not appear in epoch 5 after UnstakeCompleted"
        );

        // Summary should show 0 current stakers since Alice withdrew
        assert_eq!(result.summary.current_active_stakers, 0);
        assert_eq!(result.summary.current_total_staked, U256::ZERO);
    }

    #[test]
    fn test_staker_aggregate_correct_after_unstake_completed() {
        let alice = address!("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
        let stake_amount = U256::from(100);

        let events = vec![
            make_event(1, StakeEvent::Created { owner: alice, amount: stake_amount }),
            make_event(3, StakeEvent::UnstakeInitiated { owner: alice }),
            make_event(4, StakeEvent::UnstakeCompleted { owner: alice }),
        ];

        let result = compute_staking_data(
            5, // current_epoch
            5, // processing_end_epoch
            &events,
            &HashMap::new(),
            &HashMap::new(),
            &HashMap::new(),
        )
        .unwrap();

        // Alice should still have an aggregate entry (she participated in epochs 1-3)
        assert!(
            result.staker_aggregates.contains_key(&alice),
            "Alice should have an aggregate entry"
        );

        let alice_aggregate = &result.staker_aggregates[&alice];

        // After completing withdrawal, current_staked should be 0
        assert_eq!(
            alice_aggregate.current_staked,
            U256::ZERO,
            "current_staked should be 0 after UnstakeCompleted"
        );

        // After completing withdrawal, is_withdrawing should be false
        assert!(
            !alice_aggregate.is_withdrawing,
            "is_withdrawing should be false after UnstakeCompleted"
        );

        // She participated in 2 epochs (1 and 3) where events occurred
        // Note: epoch 2 has no events so no snapshot is created for it
        assert_eq!(alice_aggregate.epochs_participated, 2);
    }

    #[test]
    fn test_restake_after_unstake_completed_in_same_epoch() {
        // If someone completes unstake and then stakes again in the same epoch,
        // they should appear in that epoch's positions with the new stake
        let alice = address!("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
        let initial_stake = U256::from(100);
        let new_stake = U256::from(50);

        let events = vec![
            make_event(1, StakeEvent::Created { owner: alice, amount: initial_stake }),
            make_event(2, StakeEvent::UnstakeInitiated { owner: alice }),
            // Both events in epoch 3
            make_event(3, StakeEvent::UnstakeCompleted { owner: alice }),
            make_event(3, StakeEvent::Created { owner: alice, amount: new_stake }),
        ];

        let result = compute_staking_data(
            4, // current_epoch
            4, // processing_end_epoch
            &events,
            &HashMap::new(),
            &HashMap::new(),
            &HashMap::new(),
        )
        .unwrap();

        // Epoch 3: Alice should be present with new stake, not withdrawing
        let epoch3 = result.epochs.iter().find(|e| e.epoch == 3).unwrap();
        assert!(epoch3.positions_by_staker.contains_key(&alice));
        assert_eq!(epoch3.positions_by_staker[&alice].staked_amount, new_stake);
        assert!(!epoch3.positions_by_staker[&alice].is_withdrawing);

        // Epoch 4: Alice should still be staked
        let epoch4 = result.epochs.iter().find(|e| e.epoch == 4).unwrap();
        assert!(epoch4.positions_by_staker.contains_key(&alice));
        assert_eq!(epoch4.positions_by_staker[&alice].staked_amount, new_stake);

        // Aggregate should reflect current stake
        let alice_aggregate = &result.staker_aggregates[&alice];
        assert_eq!(alice_aggregate.current_staked, new_stake);
        assert!(!alice_aggregate.is_withdrawing);
    }
}
