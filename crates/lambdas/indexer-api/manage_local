#!/bin/bash

# Script to manage local indexer and API for testing
set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Load .env file if it exists
if [ -f .env ]; then
    echo "Loading environment variables from .env file..."
    set -a
    source .env
    set +a
fi

# Ethereum mainnet configuration
VEZKC_ADDRESS="${VEZKC_ADDRESS:-0xE8Ae8eE8ffa57F6a79B6Cbe06BAFc0b05F3ffbf4}"
ZKC_ADDRESS="${ZKC_ADDRESS:-0x000006c2A22ff4A44ff1f5d0F2ed65F781F55555}"
POVW_ACCOUNTING_ADDRESS="${POVW_ACCOUNTING_ADDRESS:-0x319bd4050b2170a7aE3Ead3E6d5AB8a5c7cFBDF8}"

# Function to display usage
usage() {
    echo "Usage: $0 <command> [options]"
    echo ""
    echo "Commands:"
    echo "  run-rewards-indexer <database> [duration] [end_epoch] [end_block] [batch_size]"
    echo "                                     Run rewards-indexer to populate database"
    echo "                                     database: PostgreSQL URL"
    echo "                                               (e.g., 'postgres://user:pass@host:port/db')"
    echo "                                     duration: seconds to run (default: 120)"
    echo "                                     end_epoch: stop at this epoch (optional)"
    echo "                                     end_block: stop at this block (optional)"
    echo "                                     batch_size: blocks per batch (default: 500)"
    echo ""
    echo "  run-market-indexer <database> [duration] [start_block] [end_block] [batch_size] [cache_dir] [bento_api_url] [bento_api_key] [max_concurrent_executing]"
    echo "                                     Run market-indexer to populate database"
    echo "                                     database: PostgreSQL URL"
    echo "                                               (e.g., 'postgres://user:pass@host:port/db')"
    echo "                                     duration: seconds to run (default: 120)"
    echo "                                     start_block: block to start from (optional)"
    echo "                                     end_block: stop at this block (optional)"
    echo "                                     batch_size: blocks per batch (default: 500)"
    echo "                                     cache_dir: directory for cache file storage (optional)"
    echo "                                     bento_api_url: URL to Bento API for cycle count execution (optional)"
    echo "                                     bento_api_key: API key for Bento API (required if bento_api_url is set)"
    echo "                                     max_concurrent_executing: max concurrent execution requests (default: 20)"
    echo ""
    echo "  run-api <port> <database>         Run API server with debug logging"
    echo "                                     database: PostgreSQL URL"
    echo ""
    echo "  run-market-backfill <database> <mode> <start_block> [end_block] [cache_dir] [tx_fetch_strategy]"
    echo "                                     Run market-indexer-backfill to recompute statuses/aggregates"
    echo "                                     database: PostgreSQL URL"
    echo "                                               (e.g., 'postgres://user:pass@host:port/db')"
    echo "                                     mode: 'statuses_and_aggregates' or 'aggregates'"
    echo "                                     start_block: block to start backfill from"
    echo "                                     end_block: block to end backfill at (optional, default: latest indexed)"
    echo "                                     cache_dir: directory for cache file storage (optional)"
    echo "                                     tx_fetch_strategy: 'block-receipts' or 'tx-by-hash' (optional, default: block-receipts)"
    echo ""
    echo "Environment variables (Rewards Indexer):"
    echo "  ZKC_RPC_URL                        Required: Ethereum RPC endpoint for ZKC/veZKC"
    echo "  VEZKC_ADDRESS                      Optional: veZKC contract address"
    echo "  ZKC_ADDRESS                        Optional: ZKC token address"
    echo "  POVW_ACCOUNTING_ADDRESS            Optional: PoVW accounting address"
    echo ""
    echo "Environment variables (Market Indexer):"
    echo "  MARKET_RPC_URL                     Required: RPC endpoint for Boundless Market"
    echo "  BOUNDLESS_MARKET_ADDRESS           Required: Boundless Market contract address"
    echo "  MARKET_INDEXER_LOG_FILE            Optional: File path to write indexer logs (if not set, logs go to stdout/stderr)"
    exit 1
}

# Function to check RPC URL
check_rpc_url() {
    local rpc_type="$1"  # Either "zkc" or "market"

    if [ "$rpc_type" == "zkc" ]; then
        if [ -z "$ZKC_RPC_URL" ]; then
            echo -e "${RED}Error: ZKC_RPC_URL environment variable is not set${NC}"
            echo "Please set it to your Ethereum RPC endpoint for ZKC/veZKC contracts"
            exit 1
        fi
    elif [ "$rpc_type" == "market" ]; then
        if [ -z "$MARKET_RPC_URL" ]; then
            echo -e "${RED}Error: MARKET_RPC_URL environment variable is not set${NC}"
            echo "Please set it to your RPC endpoint for Boundless Market"
            exit 1
        fi
        if [ -z "$BOUNDLESS_MARKET_ADDRESS" ]; then
            echo -e "${RED}Error: BOUNDLESS_MARKET_ADDRESS environment variable is not set${NC}"
            echo "Please set it to the Boundless Market contract address"
            exit 1
        fi
    fi
}

# Function to detect database type and prepare database URL
# Returns: db_url (with prefix) and is_postgres flag
prepare_database() {
    local db_input="$1"
    local is_postgres="false"
    local db_url=""

    # Check if input is a PostgreSQL URL
    if [[ "$db_input" =~ ^postgres(ql)?:// ]]; then
        is_postgres="true"
        db_url="$db_input"
        echo -e "${GREEN}Detected PostgreSQL database${NC}" >&2
    else
        echo -e "${RED}Error: Expected a PostgreSQL URL (postgres://...)${NC}" >&2
        exit 1
    fi

    echo "$db_url|$is_postgres"
}

# Function to build binaries
build_binaries() {
    echo -e "${GREEN}Building required binaries...${NC}"
    cd ../../.. || exit 1

    if [ "$1" == "rewards-indexer" ] || [ "$1" == "both" ]; then
        echo "Building rewards-indexer..."
        cargo build -p boundless-indexer --bin rewards-indexer
    fi

    if [ "$1" == "market-indexer" ] || [ "$1" == "both" ]; then
        echo "Building market-indexer..."
        cargo build -p boundless-indexer --bin market-indexer
    fi

    if [ "$1" == "api" ] || [ "$1" == "both" ]; then
        echo "Building local-server..."
        cargo build -p indexer-api --bin local-server
    fi

    if [ "$1" == "market-backfill" ] || [ "$1" == "both" ]; then
        echo "Building market-indexer-backfill..."
        cargo build -p boundless-indexer --bin market-indexer-backfill
    fi

    cd - > /dev/null || exit 1
}

# Function to run rewards indexer
run_rewards_indexer() {
    local db_input="$1"
    local duration="${2:-120}"
    local end_epoch="$3"
    local end_block="$4"
    local batch_size="$5"

    check_rpc_url "zkc"

    # Validate arguments
    if [ -z "$db_input" ]; then
        echo -e "${RED}Error: Database path or URL required${NC}"
        usage
    fi

    # Prepare database
    local db_result=$(prepare_database "$db_input")
    local db_url=$(echo "$db_result" | cut -d'|' -f1)
    local is_postgres=$(echo "$db_result" | cut -d'|' -f2)

    # Build the indexer
    build_binaries "rewards-indexer"

    echo -e "${GREEN}Running rewards-indexer for $duration seconds...${NC}"
    echo "Database: $db_url"
    echo "RPC URL: $ZKC_RPC_URL"
    if [ ! -z "$end_epoch" ]; then
        echo "End epoch: $end_epoch"
    fi
    if [ ! -z "$end_block" ]; then
        echo "End block: $end_block"
    fi
    if [ ! -z "$batch_size" ]; then
        echo "Batch size: $batch_size"
    fi
    echo ""

    # Build command with optional parameters
    local cmd="../../../target/debug/rewards-indexer"
    cmd="$cmd --rpc-url \"$ZKC_RPC_URL\""
    cmd="$cmd --vezkc-address \"$VEZKC_ADDRESS\""
    cmd="$cmd --zkc-address \"$ZKC_ADDRESS\""
    cmd="$cmd --povw-accounting-address \"$POVW_ACCOUNTING_ADDRESS\""
    cmd="$cmd --db \"$db_url\""
    cmd="$cmd --interval 600"

    if [ ! -z "$end_epoch" ]; then
        cmd="$cmd --end-epoch $end_epoch"
    fi
    if [ ! -z "$end_block" ]; then
        cmd="$cmd --end-block $end_block"
    fi
    if [ ! -z "$batch_size" ]; then
        cmd="$cmd --batch-size $batch_size"
    fi

    # Run the indexer in background
    DATABASE_URL="$db_url" \
    VEZKC_ADDRESS="$VEZKC_ADDRESS" \
    ZKC_ADDRESS="$ZKC_ADDRESS" \
    POVW_ACCOUNTING_ADDRESS="$POVW_ACCOUNTING_ADDRESS" \
    RUST_LOG="$RUST_LOG" \
    eval "$cmd &"

    INDEXER_PID=$!

    # Show progress
    echo -n "Populating database"
    for i in $(seq 1 "$duration"); do
        if ! kill -0 $INDEXER_PID 2>/dev/null; then
            echo ""
            echo -e "${RED}Indexer stopped unexpectedly${NC}"
            exit 1
        fi
        sleep 1
        echo -n "."
    done
    echo ""

    # Stop the indexer
    if kill -0 $INDEXER_PID 2>/dev/null; then
        echo "Stopping indexer..."
        kill $INDEXER_PID 2>/dev/null || true
        wait $INDEXER_PID 2>/dev/null || true
    fi

    echo -e "${GREEN}Database populated successfully!${NC}"
    echo "Database: $db_url"
}

# Function to run market indexer
run_market_indexer() {
    local db_input="$1"
    local duration="${2:-120}"
    local start_block="$3"
    local end_block="$4"
    local batch_size="$5"
    local cache_dir="$6"
    local bento_api_url="$7"
    local bento_api_key="$8"
    local max_concurrent_executing="$9"

    check_rpc_url "market"

    # Validate arguments
    if [ -z "$db_input" ]; then
        echo -e "${RED}Error: Database path or URL required${NC}"
        usage
    fi

    # Prepare database
    local db_result=$(prepare_database "$db_input")
    local db_url=$(echo "$db_result" | cut -d'|' -f1)
    local is_postgres=$(echo "$db_result" | cut -d'|' -f2)

    # Handle cache directory if provided
    local cache_uri=""
    if [ ! -z "$cache_dir" ]; then
        # Convert to absolute path if relative
        if [[ ! "$cache_dir" = /* ]]; then
            cache_dir="$(pwd)/$cache_dir"
        fi

        # Create cache directory if it doesn't exist
        if [ ! -d "$cache_dir" ]; then
            echo -e "${GREEN}Creating cache directory: $cache_dir${NC}"
            mkdir -p "$cache_dir"
        fi

        cache_uri="file://$cache_dir"
    fi

    # Build the indexer
    build_binaries "market-indexer"

    echo -e "${GREEN}Running market-indexer for $duration seconds...${NC}"
    echo "Database: $db_url"
    echo "RPC URL: $MARKET_RPC_URL"
    echo "Boundless Market Address: $BOUNDLESS_MARKET_ADDRESS"
    if [ ! -z "$start_block" ]; then
        echo "Start block: $start_block"
    fi
    if [ ! -z "$end_block" ]; then
        echo "End block: $end_block"
    fi
    if [ ! -z "$batch_size" ]; then
        echo "Batch size: $batch_size"
    fi
    if [ ! -z "$cache_uri" ]; then
        echo "Cache directory: $cache_dir"
    fi
    if [ ! -z "$bento_api_url" ]; then
        echo "Bento API URL: $bento_api_url"
        echo "Bento API Key: (set)"
        if [ ! -z "$max_concurrent_executing" ]; then
            echo "Max concurrent executing: $max_concurrent_executing"
        fi
    fi
    echo ""

    # Use log file from environment variable if provided
    local log_file="${MARKET_INDEXER_LOG_FILE:-}"

    # Build command with optional parameters
    local cmd="../../../target/debug/market-indexer"
    cmd="$cmd --rpc-url \"$MARKET_RPC_URL\""
    cmd="$cmd --boundless-market-address \"$BOUNDLESS_MARKET_ADDRESS\""
    cmd="$cmd --db \"$db_url\""
    cmd="$cmd --interval 1"

    if [ ! -z "$start_block" ]; then
        cmd="$cmd --start-block $start_block"
    fi
    if [ ! -z "$end_block" ]; then
        cmd="$cmd --end-block $end_block"
    fi
    if [ ! -z "$batch_size" ]; then
        cmd="$cmd --batch-size $batch_size"
    fi
    if [ ! -z "$cache_uri" ]; then
        cmd="$cmd --cache-uri \"$cache_uri\""
    fi
    if [ ! -z "$bento_api_url" ]; then
        cmd="$cmd --bento-api-url \"$bento_api_url\""
        if [ ! -z "$bento_api_key" ]; then
            cmd="$cmd --bento-api-key \"$bento_api_key\""
        fi
        if [ ! -z "$max_concurrent_executing" ]; then
            cmd="$cmd --max-concurrent-executing $max_concurrent_executing"
        fi
    fi

    # Run the indexer in background, optionally redirecting logs to file
    if [ ! -z "$log_file" ]; then
        # Create log file and parent directory if they don't exist
        local log_dir=$(dirname "$log_file")
        if [ ! -d "$log_dir" ] && [ "$log_dir" != "." ]; then
            mkdir -p "$log_dir"
        fi
        touch "$log_file"
        echo -e "${GREEN}Logs will be written to: $log_file${NC}"
        DATABASE_URL="$db_url" \
        BOUNDLESS_MARKET_ADDRESS="$BOUNDLESS_MARKET_ADDRESS" \
        RUST_LOG="$RUST_LOG" \
        eval "$cmd > \"$log_file\" 2>&1 &"
    else
        DATABASE_URL="$db_url" \
        BOUNDLESS_MARKET_ADDRESS="$BOUNDLESS_MARKET_ADDRESS" \
        RUST_LOG="$RUST_LOG" \
        eval "$cmd &"
    fi

    INDEXER_PID=$!

    # Show progress
    echo -n "Populating database"
    for i in $(seq 1 "$duration"); do
        if ! kill -0 $INDEXER_PID 2>/dev/null; then
            echo ""
            echo -e "${RED}Indexer stopped unexpectedly${NC}"
            if [ ! -z "$log_file" ]; then
                echo -e "${YELLOW}Check logs in: $log_file${NC}"
            fi
            exit 1
        fi
        sleep 1
        echo -n "."
    done
    echo ""

    # Stop the indexer
    if kill -0 $INDEXER_PID 2>/dev/null; then
        echo "Stopping indexer..."
        kill $INDEXER_PID 2>/dev/null || true
        wait $INDEXER_PID 2>/dev/null || true
    fi

    echo -e "${GREEN}Database populated successfully!${NC}"
    echo "Database: $db_url"
    if [ ! -z "$log_file" ]; then
        echo "Logs: $log_file"
    fi
}

# Function to run market backfill
run_market_backfill() {
    local db_input="$1"
    local mode="$2"
    local start_block="$3"
    local end_block="$4"
    local cache_dir="$5"
    local tx_fetch_strategy="${6:-block-receipts}"

    check_rpc_url "market"

    # Validate arguments
    if [ -z "$db_input" ] || [ -z "$mode" ] || [ -z "$start_block" ]; then
        echo -e "${RED}Error: Database, mode, and start_block are required${NC}"
        usage
    fi

    # Validate mode
    if [ "$mode" != "statuses_and_aggregates" ] && [ "$mode" != "aggregates" ]; then
        echo -e "${RED}Error: Invalid mode: $mode. Use 'statuses_and_aggregates' or 'aggregates'${NC}"
        usage
    fi

    local db_url=""
    if [[ "$db_input" =~ ^postgres(ql)?:// ]]; then
        db_url="$db_input"
        echo -e "${GREEN}Using PostgreSQL database${NC}"
    else
        echo -e "${RED}Error: Expected a PostgreSQL URL (postgres://...)${NC}"
        exit 1
    fi

    # Handle cache directory if provided
    local cache_uri=""
    if [ ! -z "$cache_dir" ]; then
        # Convert to absolute path if relative
        if [[ ! "$cache_dir" = /* ]]; then
            cache_dir="$(pwd)/$cache_dir"
        fi

        # Create cache directory if it doesn't exist
        if [ ! -d "$cache_dir" ]; then
            echo -e "${GREEN}Creating cache directory: $cache_dir${NC}"
            mkdir -p "$cache_dir"
        fi

        cache_uri="file://$cache_dir"
    fi

    # Build the backfill binary
    build_binaries "market-backfill"

    echo -e "${GREEN}Running market-indexer-backfill...${NC}"
    echo "Database: $db_url"
    echo "RPC URL: $MARKET_RPC_URL"
    echo "Boundless Market Address: $BOUNDLESS_MARKET_ADDRESS"
    echo "Mode: $mode"
    echo "Start block: $start_block"
    if [ ! -z "$end_block" ]; then
        echo "End block: $end_block"
    fi
    if [ ! -z "$cache_uri" ]; then
        echo "Cache directory: $cache_dir"
    fi
    echo "Transaction fetch strategy: $tx_fetch_strategy"
    echo ""

    # Build command with required and optional parameters
    local cmd="../../../target/debug/market-indexer-backfill"
    cmd="$cmd --mode \"$mode\""
    cmd="$cmd --rpc-url \"$MARKET_RPC_URL\""
    cmd="$cmd --boundless-market-address \"$BOUNDLESS_MARKET_ADDRESS\""
    cmd="$cmd --db \"$db_url\""
    cmd="$cmd --start-block $start_block"
    cmd="$cmd --tx-fetch-strategy \"$tx_fetch_strategy\""

    if [ ! -z "$end_block" ]; then
        cmd="$cmd --end-block $end_block"
    fi
    if [ ! -z "$cache_uri" ]; then
        cmd="$cmd --cache-uri \"$cache_uri\""
    fi

    # Run the backfill
    DATABASE_URL="$db_url" \
    BOUNDLESS_MARKET_ADDRESS="$BOUNDLESS_MARKET_ADDRESS" \
    RUST_LOG="$RUST_LOG" \
    eval "$cmd"

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Backfill completed successfully!${NC}"
        echo "Database: $db_url"
    else
        echo -e "${RED}Backfill failed${NC}"
        exit 1
    fi
}

# Function to run API
run_api() {
    local port="$1"
    local db_input="$2"

    # Validate arguments
    if [ -z "$port" ] || [ -z "$db_input" ]; then
        echo -e "${RED}Error: Port and database path or URL required${NC}"
        usage
    fi

    local db_url=""
    if [[ "$db_input" =~ ^postgres(ql)?:// ]]; then
        db_url="$db_input"
        echo -e "${GREEN}Using PostgreSQL database${NC}"
    else
        echo -e "${RED}Error: Expected a PostgreSQL URL (postgres://...)${NC}"
        exit 1
    fi

    # Build the API server
    build_binaries "api"

    echo -e "${GREEN}Starting API server...${NC}"
    echo "Port: $port"
    echo "Database: $db_url"
    echo ""
    echo "http://localhost:$port/docs"
    echo ""

    DB_URL="$db_url" \
    PORT="$port" \
    RUST_LOG=debug \
    ../../../target/debug/local-server
}

# Main script logic
if [ $# -lt 1 ]; then
    usage
fi

COMMAND="$1"
shift

case "$COMMAND" in
    run-rewards-indexer)
        run_rewards_indexer "$@"
        ;;
    run-market-indexer)
        run_market_indexer "$@"
        ;;
    run-market-backfill)
        run_market_backfill "$@"
        ;;
    run-api)
        run_api "$@"
        ;;
    *)
        echo -e "${RED}Unknown command: $COMMAND${NC}"
        usage
        ;;
esac