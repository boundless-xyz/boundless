#!/bin/bash

# Script to manage local indexer and API for testing
set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Load .env file if it exists
if [ -f .env ]; then
    echo "Loading environment variables from .env file..."
    set -a
    source .env
    set +a
fi

# Ethereum mainnet configuration
VEZKC_ADDRESS="${VEZKC_ADDRESS:-0xE8Ae8eE8ffa57F6a79B6Cbe06BAFc0b05F3ffbf4}"
ZKC_ADDRESS="${ZKC_ADDRESS:-0x000006c2A22ff4A44ff1f5d0F2ed65F781F55555}"
POVW_ACCOUNTING_ADDRESS="${POVW_ACCOUNTING_ADDRESS:-0x319bd4050b2170a7aE3Ead3E6d5AB8a5c7cFBDF8}"
RUST_LOG="${RUST_LOG:-boundless_indexer=debug,info}"

# Function to display usage
usage() {
    echo "Usage: $0 <command> [options]"
    echo ""
    echo "Commands:"
    echo "  run-rewards-indexer"
    echo "    Run rewards-indexer to populate database"
    echo ""
    echo "    Required:"
    echo "      --database URL              PostgreSQL URL (e.g., 'postgres://user:pass@host:port/db')"
    echo ""
    echo "    Optional:"
    echo "      --duration SECONDS          Seconds to run (default: 120)"
    echo "      --end-epoch EPOCH          Stop at this epoch"
    echo "      --end-block BLOCK         Stop at this block"
    echo "      --batch-size SIZE         Blocks per batch (default: 500)"
    echo ""
    echo "  run-market-indexer"
    echo "    Run market-indexer to populate database"
    echo ""
    echo "    Required:"
    echo "      --database URL              PostgreSQL URL (e.g., 'postgres://user:pass@host:port/db')"
    echo ""
    echo "    Optional:"
    echo "      --start-block BLOCK        Block to start from"
    echo "      --end-block BLOCK         Stop at this block"
    echo "      --batch-size SIZE         Blocks per batch (default: 9999)"
    echo "      --cache-dir DIR           Directory for cache file storage"
    echo "      --bento-api-url URL       URL to Bento API for cycle count execution (requires --bento-api-key)"
    echo "      --bento-api-key KEY       API key for Bento API (requires --bento-api-url)"
    echo "      --max-concurrent-executing NUM  Max concurrent execution requests (default: 20)"
    echo ""
    echo "    Press Ctrl+C to stop the indexer"
    echo ""
    echo "  run-api"
    echo "    Run API server with debug logging"
    echo ""
    echo "    Required:"
    echo "      --port PORT                Port to run the API server on"
    echo "      --database URL             PostgreSQL URL (e.g., 'postgres://user:pass@host:port/db')"
    echo ""
    echo "  run-market-backfill"
    echo "    Run market-indexer-backfill to recompute statuses/aggregates/chain_data"
    echo ""
    echo "    Required:"
    echo "      --database URL             PostgreSQL URL (e.g., 'postgres://user:pass@host:port/db')"
    echo "      --mode MODE                'statuses_and_aggregates', 'aggregates', or 'chain_data'"
    echo "      --start-block BLOCK        Block to start backfill from (required if --lookback-blocks not provided)"
    echo "      --lookback-blocks NUM      Number of blocks to look back from current (required if --start-block not provided)"
    echo "                                 Either --start-block or --lookback-blocks must be provided, but not both"
    echo ""
    echo "    Optional:"
    echo "      --end-block BLOCK         Block to end backfill at (default: latest indexed)"
    echo "      --cache-dir DIR           Directory for cache file storage"
    echo "      --tx-fetch-strategy STR   'block-receipts' or 'tx-by-hash' (default: block-receipts)"
    echo "      --chain-data-batch-delay-ms MS  Delay in milliseconds between batches during chain_data backfill (default: 1000)"
    echo ""
    echo "  Examples:"
    echo "    ./manage_local run-market-indexer --database postgres://user:pass@host:5432/db --start-block 7200 --end-block 40697700 --batch-size 9999 --cache-dir ./cache"
    echo ""
    echo "    ./manage_local run-market-backfill --database postgres://... --mode chain_data --start-block 12345"
    echo ""
    echo "    ./manage_local run-market-backfill --database postgres://... --mode chain_data --lookback-blocks 1000 --end-block 20000"
    echo ""
    echo "Environment variables (Rewards Indexer):"
    echo "  ZKC_RPC_URL                        Required: Ethereum RPC endpoint for ZKC/veZKC"
    echo "  VEZKC_ADDRESS                      Optional: veZKC contract address"
    echo "  ZKC_ADDRESS                        Optional: ZKC token address"
    echo "  POVW_ACCOUNTING_ADDRESS            Optional: PoVW accounting address"
    echo ""
    echo "Environment variables (Market Indexer):"
    echo "  MARKET_RPC_URL                     Required: RPC endpoint for Boundless Market"
    echo "  BOUNDLESS_MARKET_ADDRESS           Required: Boundless Market contract address"
    echo "  MARKET_INDEXER_LOG_FILE            Optional: File path to write indexer logs (if not set, logs go to stdout/stderr)"
    exit 1
}

# Function to check RPC URL
check_rpc_url() {
    local rpc_type="$1"  # Either "zkc" or "market"

    if [ "$rpc_type" == "zkc" ]; then
        if [ -z "$ZKC_RPC_URL" ]; then
            echo -e "${RED}Error: ZKC_RPC_URL environment variable is not set${NC}"
            echo "Please set it to your Ethereum RPC endpoint for ZKC/veZKC contracts"
            exit 1
        fi
    elif [ "$rpc_type" == "market" ]; then
        if [ -z "$MARKET_RPC_URL" ]; then
            echo -e "${RED}Error: MARKET_RPC_URL environment variable is not set${NC}"
            echo "Please set it to your RPC endpoint for Boundless Market"
            exit 1
        fi
        if [ -z "$BOUNDLESS_MARKET_ADDRESS" ]; then
            echo -e "${RED}Error: BOUNDLESS_MARKET_ADDRESS environment variable is not set${NC}"
            echo "Please set it to the Boundless Market contract address"
            exit 1
        fi
    fi
}

# Function to detect database type and prepare database URL
# Returns: db_url (with prefix) and is_postgres flag
prepare_database() {
    local db_input="$1"
    local is_postgres="false"
    local db_url=""

    # Check if input is a PostgreSQL URL
    if [[ "$db_input" =~ ^postgres(ql)?:// ]]; then
        is_postgres="true"
        db_url="$db_input"
        echo -e "${GREEN}Detected PostgreSQL database${NC}" >&2
    else
        echo -e "${RED}Error: Expected a PostgreSQL URL (postgres://...)${NC}" >&2
        exit 1
    fi

    echo "$db_url|$is_postgres"
}

# Function to build binaries
build_binaries() {
    echo -e "${GREEN}Building required binaries...${NC}"
    cd ../../.. || exit 1

    if [ "$1" == "rewards-indexer" ] || [ "$1" == "both" ]; then
        echo "Building rewards-indexer..."
        cargo build -p boundless-indexer --bin rewards-indexer
    fi

    if [ "$1" == "market-indexer" ] || [ "$1" == "both" ]; then
        echo "Building market-indexer..."
        cargo build -p boundless-indexer --bin market-indexer
    fi

    if [ "$1" == "api" ] || [ "$1" == "both" ]; then
        echo "Building local-server..."
        cargo build -p indexer-api --bin local-server
    fi

    if [ "$1" == "market-backfill" ] || [ "$1" == "both" ]; then
        echo "Building market-indexer-backfill..."
        cargo build -p boundless-indexer --bin market-indexer-backfill
    fi

    cd - > /dev/null || exit 1
}

# Function to run rewards indexer
run_rewards_indexer() {
    local database=""
    local duration="120"
    local end_epoch=""
    local end_block=""
    local batch_size=""

    # Parse named arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --database) database="$2"; shift 2 ;;
            --duration) duration="$2"; shift 2 ;;
            --end-epoch) end_epoch="$2"; shift 2 ;;
            --end-block) end_block="$2"; shift 2 ;;
            --batch-size) batch_size="$2"; shift 2 ;;
            -h|--help) usage ;;
            *) echo -e "${RED}Unknown option: $1${NC}"; usage ;;
        esac
    done

    check_rpc_url "zkc"

    # Validate required arguments
    if [ -z "$database" ]; then
        echo -e "${RED}Error: --database is required${NC}"
        usage
    fi

    local db_input="$database"

    # Prepare database
    local db_result=$(prepare_database "$db_input")
    local db_url=$(echo "$db_result" | cut -d'|' -f1)
    local is_postgres=$(echo "$db_result" | cut -d'|' -f2)

    # Build the indexer
    build_binaries "rewards-indexer"

    echo -e "${GREEN}Running rewards-indexer for $duration seconds...${NC}"
    echo "Database: $db_url"
    echo "RPC URL: $ZKC_RPC_URL"
    if [ ! -z "$end_epoch" ]; then
        echo "End epoch: $end_epoch"
    fi
    if [ ! -z "$end_block" ]; then
        echo "End block: $end_block"
    fi
    if [ ! -z "$batch_size" ]; then
        echo "Batch size: $batch_size"
    fi
    echo ""

    # Build command with optional parameters
    local cmd="../../../target/debug/rewards-indexer"
    cmd="$cmd --rpc-url \"$ZKC_RPC_URL\""
    cmd="$cmd --vezkc-address \"$VEZKC_ADDRESS\""
    cmd="$cmd --zkc-address \"$ZKC_ADDRESS\""
    cmd="$cmd --povw-accounting-address \"$POVW_ACCOUNTING_ADDRESS\""
    cmd="$cmd --db \"$db_url\""
    cmd="$cmd --interval 600"

    if [ ! -z "$end_epoch" ]; then
        cmd="$cmd --end-epoch $end_epoch"
    fi
    if [ ! -z "$end_block" ]; then
        cmd="$cmd --end-block $end_block"
    fi
    if [ ! -z "$batch_size" ]; then
        cmd="$cmd --batch-size $batch_size"
    fi

    # Run the indexer in background
    DATABASE_URL="$db_url" \
    VEZKC_ADDRESS="$VEZKC_ADDRESS" \
    ZKC_ADDRESS="$ZKC_ADDRESS" \
    POVW_ACCOUNTING_ADDRESS="$POVW_ACCOUNTING_ADDRESS" \
    RUST_LOG="$RUST_LOG" \
    eval "$cmd &"

    INDEXER_PID=$!

    # Show progress
    echo -n "Populating database"
    for i in $(seq 1 "$duration"); do
        if ! kill -0 $INDEXER_PID 2>/dev/null; then
            echo ""
            echo -e "${RED}Indexer stopped unexpectedly${NC}"
            exit 1
        fi
        sleep 1
        echo -n "."
    done
    echo ""

    # Stop the indexer
    if kill -0 $INDEXER_PID 2>/dev/null; then
        echo "Stopping indexer..."
        kill $INDEXER_PID 2>/dev/null || true
        wait $INDEXER_PID 2>/dev/null || true
    fi

    echo -e "${GREEN}Database populated successfully!${NC}"
    echo "Database: $db_url"
}

# Function to run market indexer
run_market_indexer() {
    local database=""
    local start_block=""
    local end_block=""
    local batch_size=""
    local cache_dir=""
    local bento_api_url=""
    local bento_api_key=""
    local max_concurrent_executing=""

    # Parse named arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --database) database="$2"; shift 2 ;;
            --start-block) start_block="$2"; shift 2 ;;
            --end-block) end_block="$2"; shift 2 ;;
            --batch-size) batch_size="$2"; shift 2 ;;
            --cache-dir) cache_dir="$2"; shift 2 ;;
            --bento-api-url) bento_api_url="$2"; shift 2 ;;
            --bento-api-key) bento_api_key="$2"; shift 2 ;;
            --max-concurrent-executing) max_concurrent_executing="$2"; shift 2 ;;
            -h|--help) usage ;;
            *) echo -e "${RED}Unknown option: $1${NC}"; usage ;;
        esac
    done

    check_rpc_url "market"

    # Validate required arguments
    if [ -z "$database" ]; then
        echo -e "${RED}Error: --database is required${NC}"
        usage
    fi

    # Validate bento arguments
    if [ ! -z "$bento_api_url" ] && [ -z "$bento_api_key" ]; then
        echo -e "${RED}Error: --bento-api-key is required when --bento-api-url is provided${NC}"
        usage
    fi
    if [ ! -z "$bento_api_key" ] && [ -z "$bento_api_url" ]; then
        echo -e "${RED}Error: --bento-api-url is required when --bento-api-key is provided${NC}"
        usage
    fi

    local db_input="$database"

    # Prepare database
    local db_result=$(prepare_database "$db_input")
    local db_url=$(echo "$db_result" | cut -d'|' -f1)
    local is_postgres=$(echo "$db_result" | cut -d'|' -f2)

    # Handle cache directory if provided
    local cache_uri=""
    if [ ! -z "$cache_dir" ]; then
        # Convert to absolute path if relative
        if [[ ! "$cache_dir" = /* ]]; then
            cache_dir="$(pwd)/$cache_dir"
        fi

        # Create cache directory if it doesn't exist
        if [ ! -d "$cache_dir" ]; then
            echo -e "${GREEN}Creating cache directory: $cache_dir${NC}"
            mkdir -p "$cache_dir"
        fi

        cache_uri="file://$cache_dir"
    fi

    # Build the indexer
    build_binaries "market-indexer"

    echo -e "${GREEN}Running market-indexer (Ctrl+C to stop)...${NC}"
    echo "Database: $db_url"
    echo "RPC URL: $MARKET_RPC_URL"
    echo "Boundless Market Address: $BOUNDLESS_MARKET_ADDRESS"
    if [ ! -z "$start_block" ]; then
        echo "Start block: $start_block"
    fi
    if [ ! -z "$end_block" ]; then
        echo "End block: $end_block"
    fi
    if [ ! -z "$batch_size" ]; then
        echo "Batch size: $batch_size"
    fi
    if [ ! -z "$cache_uri" ]; then
        echo "Cache directory: $cache_dir"
    fi
    if [ ! -z "$bento_api_url" ] && [ ! -z "$bento_api_key" ]; then
        echo "Bento API URL: $bento_api_url"
        echo "Bento API Key: (set)"
        if [ ! -z "$max_concurrent_executing" ]; then
            echo "Max concurrent executing: $max_concurrent_executing"
        fi
    fi
    echo ""

    # Build command with optional parameters
    local cmd="../../../target/debug/market-indexer"
    cmd="$cmd --rpc-url \"$MARKET_RPC_URL\""
    cmd="$cmd --boundless-market-address \"$BOUNDLESS_MARKET_ADDRESS\""
    cmd="$cmd --db \"$db_url\""
    cmd="$cmd --interval 1"

    if [ ! -z "$start_block" ]; then
        cmd="$cmd --start-block $start_block"
    fi
    if [ ! -z "$end_block" ]; then
        cmd="$cmd --end-block $end_block"
    fi
    if [ ! -z "$batch_size" ]; then
        cmd="$cmd --batch-size $batch_size"
    fi
    if [ ! -z "$cache_uri" ]; then
        cmd="$cmd --cache-uri \"$cache_uri\""
    fi
    if [ ! -z "$bento_api_url" ] && [ ! -z "$bento_api_key" ]; then
        cmd="$cmd --bento-api-url \"$bento_api_url\""
        cmd="$cmd --bento-api-key \"$bento_api_key\""
        if [ ! -z "$max_concurrent_executing" ]; then
            cmd="$cmd --max-concurrent-executing $max_concurrent_executing"
        fi
    fi

    DATABASE_URL="$db_url" \
    BOUNDLESS_MARKET_ADDRESS="$BOUNDLESS_MARKET_ADDRESS" \
    RUST_LOG="$RUST_LOG" \
    eval "$cmd"
}

# Function to run market backfill
run_market_backfill() {
    local database=""
    local mode=""
    local start_block=""
    local end_block=""
    local cache_dir=""
    local tx_fetch_strategy="block-receipts"
    local lookback_blocks=""
    local chain_data_batch_delay_ms=""

    # Parse named arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --database) database="$2"; shift 2 ;;
            --mode) mode="$2"; shift 2 ;;
            --start-block) start_block="$2"; shift 2 ;;
            --end-block) end_block="$2"; shift 2 ;;
            --cache-dir) cache_dir="$2"; shift 2 ;;
            --tx-fetch-strategy) tx_fetch_strategy="$2"; shift 2 ;;
            --lookback-blocks) lookback_blocks="$2"; shift 2 ;;
            --chain-data-batch-delay-ms) chain_data_batch_delay_ms="$2"; shift 2 ;;
            -h|--help) usage ;;
            *) echo -e "${RED}Unknown option: $1${NC}"; usage ;;
        esac
    done

    check_rpc_url "market"

    # Validate required arguments
    if [ -z "$database" ]; then
        echo -e "${RED}Error: --database is required${NC}"
        usage
    fi
    if [ -z "$mode" ]; then
        echo -e "${RED}Error: --mode is required${NC}"
        usage
    fi

    # Validate that either start_block or lookback_blocks is provided (but not both)
    if [ ! -z "$start_block" ] && [ ! -z "$lookback_blocks" ]; then
        echo -e "${RED}Error: Cannot specify both --start-block and --lookback-blocks${NC}"
        usage
    fi
    if [ -z "$start_block" ] && [ -z "$lookback_blocks" ]; then
        echo -e "${RED}Error: Either --start-block or --lookback-blocks must be provided${NC}"
        usage
    fi

    local db_input="$database"

    # Validate mode
    if [ "$mode" != "statuses_and_aggregates" ] && [ "$mode" != "aggregates" ] && [ "$mode" != "chain_data" ]; then
        echo -e "${RED}Error: Invalid mode: $mode. Use 'statuses_and_aggregates', 'aggregates', or 'chain_data'${NC}"
        usage
    fi

    local db_url=""
    if [[ "$db_input" =~ ^postgres(ql)?:// ]]; then
        db_url="$db_input"
        echo -e "${GREEN}Using PostgreSQL database${NC}"
    else
        echo -e "${RED}Error: Expected a PostgreSQL URL (postgres://...)${NC}"
        exit 1
    fi

    # Handle cache directory if provided
    local cache_uri=""
    if [ ! -z "$cache_dir" ]; then
        # Convert to absolute path if relative
        if [[ ! "$cache_dir" = /* ]]; then
            cache_dir="$(pwd)/$cache_dir"
        fi

        # Create cache directory if it doesn't exist
        if [ ! -d "$cache_dir" ]; then
            echo -e "${GREEN}Creating cache directory: $cache_dir${NC}"
            mkdir -p "$cache_dir"
        fi

        cache_uri="file://$cache_dir"
    fi

    # Build the backfill binary
    build_binaries "market-backfill"

    echo -e "${GREEN}Running market-indexer-backfill...${NC}"
    echo "Database: $db_url"
    echo "RPC URL: $MARKET_RPC_URL"
    echo "Boundless Market Address: $BOUNDLESS_MARKET_ADDRESS"
    echo "Mode: $mode"
    if [ ! -z "$start_block" ]; then
        echo "Start block: $start_block"
    fi
    if [ ! -z "$lookback_blocks" ]; then
        echo "Lookback blocks: $lookback_blocks"
    fi
    if [ ! -z "$end_block" ]; then
        echo "End block: $end_block"
    fi
    if [ ! -z "$cache_uri" ]; then
        echo "Cache directory: $cache_dir"
    fi
    echo "Transaction fetch strategy: $tx_fetch_strategy"
    if [ ! -z "$chain_data_batch_delay_ms" ]; then
        echo "Chain data batch delay: ${chain_data_batch_delay_ms}ms"
    fi
    echo ""

    # Build command with required and optional parameters
    local cmd="../../../target/debug/market-indexer-backfill"
    cmd="$cmd --mode \"$mode\""
    cmd="$cmd --rpc-url \"$MARKET_RPC_URL\""
    cmd="$cmd --boundless-market-address \"$BOUNDLESS_MARKET_ADDRESS\""
    cmd="$cmd --db \"$db_url\""
    cmd="$cmd --tx-fetch-strategy \"$tx_fetch_strategy\""

    if [ ! -z "$start_block" ]; then
        cmd="$cmd --start-block $start_block"
    fi
    if [ ! -z "$lookback_blocks" ]; then
        cmd="$cmd --lookback-blocks $lookback_blocks"
    fi
    if [ ! -z "$end_block" ]; then
        cmd="$cmd --end-block $end_block"
    fi
    if [ ! -z "$cache_uri" ]; then
        cmd="$cmd --cache-uri \"$cache_uri\""
    fi
    if [ ! -z "$chain_data_batch_delay_ms" ]; then
        cmd="$cmd --chain-data-batch-delay-ms $chain_data_batch_delay_ms"
    fi

    # Run the backfill
    DATABASE_URL="$db_url" \
    BOUNDLESS_MARKET_ADDRESS="$BOUNDLESS_MARKET_ADDRESS" \
    RUST_LOG="$RUST_LOG" \
    eval "$cmd"

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Backfill completed successfully!${NC}"
        echo "Database: $db_url"
    else
        echo -e "${RED}Backfill failed${NC}"
        exit 1
    fi
}

# Function to run API
run_api() {
    local port=""
    local database=""

    # Parse named arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --port) port="$2"; shift 2 ;;
            --database) database="$2"; shift 2 ;;
            -h|--help) usage ;;
            *) echo -e "${RED}Unknown option: $1${NC}"; usage ;;
        esac
    done

    # Validate required arguments
    if [ -z "$port" ]; then
        echo -e "${RED}Error: --port is required${NC}"
        usage
    fi
    if [ -z "$database" ]; then
        echo -e "${RED}Error: --database is required${NC}"
        usage
    fi

    local db_input="$database"

    local db_url=""
    if [[ "$db_input" =~ ^postgres(ql)?:// ]]; then
        db_url="$db_input"
        echo -e "${GREEN}Using PostgreSQL database${NC}"
    else
        echo -e "${RED}Error: Expected a PostgreSQL URL (postgres://...)${NC}"
        exit 1
    fi

    # Build the API server
    build_binaries "api"

    echo -e "${GREEN}Starting API server...${NC}"
    echo "Port: $port"
    echo "Database: $db_url"
    echo ""
    echo "http://localhost:$port/docs"
    echo ""

    DB_URL="$db_url" \
    PORT="$port" \
    RUST_LOG=debug \
    ../../../target/debug/local-server
}

# Main script logic
if [ $# -lt 1 ]; then
    usage
fi

COMMAND="$1"
shift

case "$COMMAND" in
    run-rewards-indexer)
        run_rewards_indexer "$@"
        ;;
    run-market-indexer)
        run_market_indexer "$@"
        ;;
    run-market-backfill)
        run_market_backfill "$@"
        ;;
    run-api)
        run_api "$@"
        ;;
    *)
        echo -e "${RED}Unknown command: $COMMAND${NC}"
        usage
        ;;
esac