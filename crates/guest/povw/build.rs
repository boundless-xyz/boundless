// Copyright (c) 2025 RISC Zero, Inc.
//
// All rights reserved.

#[cfg(feature = "host")]
mod build_contracts {
    use std::{env, fs, path::Path};

    // Contract interface files to copy to the artifacts folder
    const INTERFACE_FILES: [&str; 3] = ["IPovwAccounting.sol", "IZKC.sol", "IPovwMint.sol"];

    // Contracts to generate bytecode for (used for deployment in tests)
    const BYTECODE_CONTRACTS: [&str; 2] = ["PovwAccounting", "PovwMint"];

    // Output filename for the generated bytecode module
    const BYTECODE_MODULE: &str = "bytecode.rs";

    /// Copy contract interface files from contracts/src/povw to src/contracts/artifacts
    fn copy_contract_interfaces() {
        let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
        let contracts_src = Path::new(&manifest_dir)
            .parent()
            .unwrap()
            .parent()
            .unwrap()
            .parent()
            .unwrap()
            .join("contracts/src/povw");

        // Early return if contracts source doesn't exist (enables cargo publish)
        if !contracts_src.exists() {
            return;
        }

        let artifacts_dir = Path::new(&manifest_dir).join("src/contracts/artifacts");
        fs::create_dir_all(&artifacts_dir).unwrap();

        println!("cargo:rerun-if-changed={}", contracts_src.display());

        for interface_file in INTERFACE_FILES {
            let src_path = contracts_src.join(interface_file);
            let dest_path = artifacts_dir.join(interface_file);

            println!("cargo:rerun-if-changed={}", src_path.display());

            if src_path.exists() {
                fs::copy(&src_path, &dest_path).unwrap();
            }
        }
    }

    /// Generate Rust bytecode module from compiled contract artifacts
    fn generate_bytecode_module() {
        let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
        let out_dir = Path::new(&manifest_dir)
            .parent()
            .unwrap()
            .parent()
            .unwrap()
            .parent()
            .unwrap()
            .join("out");

        // Early return if compiled artifacts don't exist (enables cargo publish)
        if !out_dir.exists() {
            println!("cargo:warning=Skipping bytecode generation during cargo publish");
            return;
        }

        let mut module_content =
            String::from("// Auto-generated bytecode module, do not edit manually\n\n");

        for contract in BYTECODE_CONTRACTS {
            let artifact_path = out_dir.join(format!("{contract}.sol/{contract}.json"));

            println!("cargo:rerun-if-changed={}", artifact_path.display());

            if artifact_path.exists() {
                let json_content = fs::read_to_string(&artifact_path).unwrap();
                let json: serde_json::Value = serde_json::from_str(&json_content).unwrap();

                let bytecode = json["bytecode"]["object"]
                    .as_str()
                    .unwrap_or_else(|| {
                        panic!("Failed to extract bytecode from {}", artifact_path.display())
                    })
                    .trim_start_matches("0x");

                module_content.push_str(&format!(
                    r#"alloy_sol_types::sol! {{
    #[sol(rpc, bytecode = "{}")]
    contract {} {{
        {}
    }}
}}
"#,
                    bytecode,
                    contract,
                    get_contract_constructor(contract)
                ));
            }
        }

        let dest_path = Path::new(&manifest_dir).join("src/contracts").join(BYTECODE_MODULE);
        fs::create_dir_all(dest_path.parent().unwrap()).unwrap();
        fs::write(dest_path, module_content).unwrap();
    }

    // NOTE: This is one solution to the problem of how to define the constructor function so that
    // the contract can be deployed using alloy. It has the downside that if it changes on the
    // contract, it must be updated here as well.
    /// Get the contract constructor definition for a given contract
    fn get_contract_constructor(contract: &str) -> &str {
        match contract {
            "PovwAccounting" => "constructor(address verifier, address zkc, bytes32 logUpdaterId) {}",
            "PovwMint" => "constructor(address verifier, address povwAccounting, bytes32 mintCalculatorId, address zkc, address zkcRewards) {}",
            _ => "",
        }
    }

    pub(super) fn build() {
        copy_contract_interfaces();
        generate_bytecode_module();
    }
}

#[cfg(feature = "build-guest")]
mod build_guest {
    use risc0_build_ethereum::generate_solidity_files;

    const SOLIDITY_IMAGE_ID_PATH: &str = "../../../contracts/src/libraries/PovwImageID.sol";
    const SOLIDITY_ELF_PATH: &str = "../../../contracts/test/PovwElf.sol";

    pub(super) fn build() {
        let guests = risc0_build::embed_methods();

        let solidity_opts = risc0_build_ethereum::Options::default()
            .with_image_id_sol_path(SOLIDITY_IMAGE_ID_PATH)
            .with_elf_sol_path(SOLIDITY_ELF_PATH);

        if let Err(e) = generate_solidity_files(guests.as_slice(), &solidity_opts) {
            println!("cargo:warning=Failed to generate Solidity files: {e}");
        }
    }
}

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    #[cfg(feature = "host")]
    build_contracts::build();

    #[cfg(feature = "build-guest")]
    build_guest::build();
}
